lista di cosa da fare con appunti 

il comando passato da bash
./pipex infile (file input), cmd1 cmd2 outfile

oppure
< infile cmd 1 | cmd 2 > outfile 

[x] implemetare le nostre funzioni
[x] implementare get 
[x] farti una tua libreria 
[x] farti il Makefile 
[x] implementare le giuste librerie
[x] farti una parte per le utils
[x] farti il main che con le dovute accortezze per riprodurre pipex
[x] ricardarsi di mettere le giuste cose dentro la nostra funzione main
(devi mettere argc, argv, ed **envp)
[*x] creare un infile (file di qualsiasi cosa basta che gli venga passato)
	*(volendo in teoria posso anche passargli questo)

pipex é letteralmente ricreare la funzione pipex di bash e come tale deve lavorare e dare dei risultati che 
lavorano direttamente su o un'outfile se  va tutto a cbuon fine o sennó sulla bash e in base ai casi 
vuol dire che ti dia dei messaggi di errore direttamente sullo standard error
lui lavora con un infile passato al primo comando, definito figlio (o comunque quello che é),
	 il secondo comando, definito padre, e l'outfile 
(l 'outfile viene creato poi durante la correzione ma conviene che per testarlo lo crei pure tu).
lui prende l'imput dato esegue il primo comando poi lo passa come input al secondo comando che lo lavora 
e lui passa il tutto poi all' outfile.

Sebra facile ma lui deve ricercarsi il path se é esistente 
[x] creazione di una funzione per cercare il path se é esistente (strncmp per vedere se PATH= esiste)
(attenzione a come usi perror... lui lavora direttamente sullo standard error)
devi fare un bel po' di controlli per eseguire il comando, controllare i processi 
mi sa un po'di roba in piú ancora da vedere ma va bene lo stesso

il main deve funzionare con argc e argv e vede se dentro le doppie virgolette gli passi un solo comando e che se c'é 
qualcos'altro lui da errore ( "wc -l"	 "cat -e" *) 
lui non si deve gestire la pipe ma solo i comandi 

*{lui scorre ti legge tutto quello che gli passi come stringa e di consequenza ti vede se sono piú comandi e ti dá 
errore ma noi non lo gestiamo fa tutto il computer... quindi lui se si trova appunto dei comandi li legge come 
se fossero delle stringhe con comando e argomento e appena hai le doppie virgolette lui legge tutto quello 
appunto come una stringa ma se ne trova piú di uno da errore}

facciamo prima a fare solo ció che ci viene richiesto dal subject nudo e crudo come sta messo lí senza
complicarci troppo la vita 

[v] roba da studiare

[x] perror = ti printa nello stderr(standard error) una frase di errore 
[x] execve = esegue il file puntato da filename, cioé esegue un processo all'interno di un 
			programma. 
[x] processo = ogni singolo programma in esecuzione
[x] pid = é il process identificator cioé un id che ti identifica il processo ed é un numero
			intero che identifica il processo. serve soprattuto per poetr o far comunicare piú
			processi oppure per poter sostituirne uno per un altro.
			la libreria é unistd.h
[x] waitpid = lui fa sí che aspetti che il processo termini. in generale fa si che il processo 
				apetti che quello figlio smetta di lavorare oppure si traformi
				la libreria é sys\wait.h
[x] envp = é il terxzo elemento che si puó usare in un main. é un array di stringhe
			che rappresenta l'ambiente sdi esecuzione del programma.
[x] access = lui ti vede se un file é leggibile, eseguibile, se é scrivibile e se esiste
				se non esiste ti ritorna -1.sennó 0
				la libreria é unistd.h.
[x] dup2 = sostituisce il file descriptor dato con quello che invece che gli passi tu. 
			//in generale tu lo usi pure per intercambiare tra i due o piu, é vero che lo 
			sostituisce ma quel processo lo puoi anche richiamare in seguito
[x] fork = ti crea un processo che viene eseguito per primo e poi fa il secondo processo.
			 ti crea un processo chiamato figlio che é la copia del processo attuale 
			  che puó lavorare anche in maniera indipendente dal padre.
			  il pid passato al figlio sará zero per il processo figlio mentre al 
			 padre egli avrá il suo pid
[x] exit = ti esce dal programma e ti restituisce un valore al sistema operativo e tutto ció 
			che é allocato dinamicamente viene freeato. come da linguaggio di programmazione 
			metto exit(-1) con il -1 all'interno per indicare che c'é stato un errore 
			la libreria é unistd.h oppure stdlib.h
[x] unlink = serve ad eliminare un fuile che gli passi con il suo path e quindi libera anche 
			lo spazio occupato da ció
[x] open = hai il nome del file, le flag e la modalita' di accesso
			le flag sono:O_RDONLY lui ti apre il file in lettura;
			O_WRONLY apre solo per la scrittura
			O_RDWR per fare sia scrittura che lettura
			O_CREAT se non esiste il file lo crea
			O_EXCL se il file e' gia' creato ti ritora un errore
			O_TRUNC un file esistente verra' troncato
			O_APPEND lui ti pare il file e ti appende le modifiche
			le altre non mi pare possano servire
STDOUT_FILENO = stiamo dicendo di fare riferimendo al file descriptor dello standar output

[v] funzioni che servono da ricreare all'esterno

[X] strcmp = ti da la possibilitá di vedere se c´é il path ma lo puoi utilizzare anche 
			in altre funzioni comodamente
[x] split = che non so per che possa essere utilizzato effettivamente;
[x] split potente = é effettivamente uno split che lavora in modo piú consono
[x] strnstr = lui ti cerca la prima occorrenza di quel carattere entro n caratteri
[x] substr = ti prende una sottostringa, ti alloca memoria e te la copia
[x] strlcpy = lui ti copia bello tranquillo 
[X] strlen = lunghezza di una stringa
[x] strjoin = lo uso per prendermi il path per l'eseguibile

[x]funzioni da creare 

[x] uno split in una versione piú potente
[x] le utils per lo split potente
[x] da fillare le diverse utils
[x] da fare la parte main